Redo Advent of Code 2022 with cleaner and mostly faster code.

Day 1:
2022: 66719 198551 (0.005183s,0.0043s,0.009483s)
redo: 66719 198551 (0.005274s,0.004249s,0.009523s)

Day 2:
2022: 13009 10398 (0.010052s,0.004888s,0.01494s)
redo: 13009 10398 (0.002534s,0.00356s,0.006094s)

Day 3:
2022: 7863 2488 (0.007614s,0.002415s,0.010029s)
redo: 7863 2488 (0.002286s,0.002887s,0.005173s)

Day 4:
2022: 573 867 (0.015182s,0.010012s,0.025194s)
redo: 573 867 (0.018121s,0.018668s,0.036789s)

Day 5:
2022: "RNZLFZSJH" "CNSFCGJSM" (0.009253s,0.005685s,0.014938s)
redo: "RNZLFZSJH" "CNSFCGJSM" (0.01219s,0.012396s,0.024586s)

Day 6:
2022: 1578 2178 (0.004656s,0.004749s,0.009405s)
redo: 1578 2178 (0.003032s,0.005231s,0.008263s)

Day 7:
2022: 1444896 404395 (0.018752s,0.015088s,0.03384s)
redo: 1444896 404395 (0.004125s,0.004019s,0.008144s)

Day 8: Redo uses parallel processing to go faster.
2022: 1695 287040 (0.142835s,0.324144s,0.466979s)
redo: 1695 287040 (0.050626s,0.056103s,0.106729s)

Day 9: Redo uses common code for part 1 and part 2 and goes faster
       by jumping to the destination when moving multiple spaces in
       certain cases instead of always moving one space at a time.
2022: 6181 2386 (0.40918s,0.206856s,0.616036s)
redo: 6181 2386 (0.0596s,0.180786s,0.240386s)

Day 10: Redo converts the pixels into a string, guessing on characters
        not seen and assuming the bad ones are never generated by any
        input.  Manually got the string from the pixels in 2022.
2022: 15260            (0.002604s,0.0054s,0.008004s)
redo: 15260 "PGHFGLUG" (0.001565s,0.001607s,0.003172s)

Day 11: Redo uses common code for part 1 and part 2 and goes faster
        by compiling the limited set of operations instead of parsing
	them into a more flexible expression tree and interpreting that.
2022: 54036 13237873355 (0.002699s,1.42858s,1.431279s)
redo: 54036 13237873355 (0.001776s,1.11804s,1.119816s)

Day 12: Redo uses the same A* code for both parts, while 2022 does a
        a breadth-first search for part 1 and multiple breadth-first
	searches for part 2.
2022: 534 525 (0.075153s,26.921265s,26.996418s)
redo: 534 525 (0.137966s,0.185733s,0.323699s)

Day 13: Redo is probably faster because it implements compare rather
        than (<=), which probably makes the sorting more efficient,
	and redo only scans the list once for the divider packets
	rather than twice.  Not sure why part 1 is so much faster.
	Guessing that the redo parser is faster.
2022: 5588 23958 (0.023317s,0.049673s,0.07299s)
redo: 5588 23958 (0.010326s,0.022642s,0.032968s)

Day 14: Redo first got the answer using brute-force, but, after
        looking at the 2022 solution, implemented the backtracking
	along the sand track optimization that makes part 1 about
	6 times faster and part 2 about 30 times faster than the
	brute-force.
2022: 873 24813 (0.022871s,0.193476s,0.216347s)
redo: 873 24813 (0.024745s,0.190438s,0.215183s)

Day 15: Originally tried to have each sensor divide the remaining
        search areas into uncovered rectangles and isosceles right
	triangles, but the logic was too complicated.  Then, tried to
	have each sensor divide the remaining search X ranges for
	each row into uncovered X ranges, but that was much too
	slow, even with parallel processing.  Then, reimplemented
	the 2022 algorithm with parallel processing.  The redo code
	even much faster than the 2022 code without parallel
	processing, as parallel processing speeds it up by a factor
	of about 2.3.
2022: 4886370 11374534948438 (0.004422s,3.173531s,3.177953s)
redo: 4886370 11374534948438 (0.001498s,0.056188s,0.057686s)

Day 16: Redo adds optimization of removing opened valves from the
        graph for a decent speedup for part 1.  Part 2, however,
	is too slow.  Looking at spoilers suggests a different
	approach is warranted, and taking that approach with parallel
        processing is more than 2.5 times faster than the 2022 code,
        which is good, but not good enough.
2022: 1850 2306 (47.065039s,3272.929359s,3319.994398s)
redo: 1850 2306 (6.172901s,1255.0354s,1261.208301s)

Day 17: Redo code actually finds the cycle in the tower for part 2.
        Got the answer for part 2 in 2022 with manual exploration and
        guessing.
2022: 3144 1565242165201 (0.149163s)
redo: 3144 1565242165201 (0.079094s,0.907156s,0.98625s)

Day 18: Redo uses parallel processing on part 1 and is still slightly
        slower than 2022.  Noting that the rectangular solid
        encompassing the droplet is approximately 20x20x20, the redo
        of part 2 is simpler and faster than 2022, just doing a fill
        of the encompassing rectangular solid.
2022: 4580 2610 (0.034137s,1.168475s,1.202612s)
redo: 4580 2610 (0.03707s,0.276558s,0.313628s)

Day 19: Redo gets most of its speedup by eliminating the option of
        building a bot if it had already passed on building that bot
        unless another bot has been built in the meantime.  Parallel
        processing gets an additional doubling of the speed.
2022: 960 2040 (122.277171s,191.348144s,313.625315s)
redo: 960 2040 (5.552272s,12.549449s,18.101721s)

Day 20: First attempt at redo was much slower, updating the sort index
        of every number when moving a number.  Looking at the 2022
        code, the sort index doesn't have to be an integer, which
        means that when moving a number, the sort indices of all the
        other numbers don't need to change.  Got stuck for a while due
        to assuming that there were no duplicate numbers in the input,
        since the there were no duplicate numbers in the test input.
2022: 8372 7865110481723 (0.09565s,0.972073s,1.067723s)
redo: 8372 7865110481723 (0.097767s,1.089257s,1.187024s)

Day 21:
2022: 232974643455000 3740214169961 (0.010159s,0.010092s,0.020251s)
redo: 232974643455000 3740214169961 (0.008236s,0.008398s,0.016634s)

Day 22: Redo folds the cube to determine the neighbors between faces.
        It probably has bugs for shapes other than the test case and
        my input.  For 2022, the neighbors between faces were
        determined manually for the test case and for my input data,
        so it will not work for maps of different shapes.
2022: 58248 179091 (0.151153s,0.155365s,0.306518s)
redo: 58248 179091 (0.131041s,0.230896s,0.361937s)

Day 23:
2022: 4082 1065 (0.303096s,29.089778s,29.392874s)
redo: 4082 1065 (0.33947s,29.763054s,30.102524s)

Day 24: Redo precomputes all the blizzard positions into a list of
        arrays since they cycle every 300 minutes, making it much
        faster than the 2022 code.
2022: 322 974 (222.030627s,714.573293s,936.60392s)
redo: 322 974 (3.611108s,5.629493s,9.240601s)

Day 25:
2022: "2==221=-002=0-02-000" () (0.00299s,0.000029s,0.003019s)
redo: "2==221=-002=0-02-000" () (0.004912s,0.00004s,0.004952s)
